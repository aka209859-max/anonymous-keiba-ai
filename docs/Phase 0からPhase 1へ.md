Phase 0からPhase 1へ：競走馬予測モデルのための高次元特徴量エンジニアリングと統合フレームワークに関する包括的技術報告書1. 序論：現代競馬予測におけるデータパイプラインの重要性現代の計算機科学を応用した競馬予測、特にGradient Boosting Decision Trees（GBDT）を用いたLightGBMモデルの運用において、最もクリティカルかつリソースを消費するフェーズは、生データ（Raw Data）から学習済みモデルが解釈可能な特徴量（Features）への変換プロセスである。本プロジェクトにおいて「Phase 0」と定義されるPC-KEIBAデータベース上の正規化されたリレーショナルデータは、そのままでは機械学習モデルの入力として機能しない。モデルは、過去の履歴、血統背景、当日の環境変数などが「1行のレコード」として集約された、高次元かつ整然としたベクトルを要求するからである。本報告書は、E:/anonymous-keiba-ai/models/に展開された14競馬場×3種類（Binary, Ranking, Regression）の計42モデルが必要とする「50特徴量」を、Phase 0の生データから正確かつ効率的に生成するための技術的詳細、論理的背景、および実装仕様を網羅的に解説するものである。特に、過去走データの再帰的な取得ロジック、欠損値処理の数学的正当性、および運用スクリプトprepare_features.pyの設計指針に焦点を当て、実運用に耐えうる堅牢なデータパイプラインの構築を支援することを目的とする。2. PC-KEIBAデータベース構造とPhase 0データの特性2.1 データソースとしてのPC-KEIBA本システムが依拠するPC-KEIBA Databaseは、JRA-VAN Data Lab.および地方競馬DATAから提供される公式記録を蓄積するSQLベース（PostgreSQL）のプラットフォームである。このデータベースは、競走馬の個体識別、レース結果、配当、オッズ時系列など、競馬予測に必要なあらゆる情報を網羅しているが、その構造は高度に正規化されている。例えば、あるレースの天候情報はnvd_ra（レース詳細テーブル）に存在し、各馬の負担重量はnvd_se（馬毎レース情報テーブル）に、血統情報はnvd_hn（繁殖馬マスタ）に分散して格納されている。したがって、Phase 0（生データ）からPhase 1（特徴量セット）への変換とは、本質的にこれらの分散したテーブルを特定のrace_id（レースID）をキーとして結合（JOIN）し、非正規化（Denormalization）するプロセスに他ならない。2.2 地方競馬データの特殊性と課題JRA（中央競馬）と比較して、地方競馬データは情報の粒度や欠損率において特有の課題を持つ。PC-KEIBAは地方競馬DATAに対応しており、全国の競馬場（帯広から高知まで）のデータを統一フォーマットで扱うことが可能であるが、特徴量エンジニアリングにおいては以下の点に留意する必要がある：馬場状態コードの扱い: 芝コースが存在するのは盛岡競馬場のみであり、他の多くの地方競馬場はダート専用である。しかし、データベース上はbabajotai_code_shibaとbabajotai_code_dirtの両カラムが存在する場合があり、これらを適切にハンドリングする必要がある。情報の更新頻度: 地方競馬は開催頻度が高く、速報データの取り込みと特徴量生成のサイクルを高速に回す必要がある。3. 学習済みモデルの構造解析と特徴量要件（Q1）3.1 3つのモデルタイプとその目的本プロジェクトでは、各競馬場に対して以下の3つの異なるアプローチによるモデルが配置されている。Binary Classification (二値分類モデル):ファイル名: models/binary/{keibajo}_2020-2025_v3_model.txt目的: 馬券圏内（通常は3着以内）に入る確率を予測する。出力: 0（圏外）または1（圏内）の確率値。特徴: ノイズに強く、軸馬選定に適している。Ranking Learning (ランキング学習モデル):ファイル名: models/ranking/{keibajo}_2020-2025_v3_with_race_id_ranking_model.txt目的: レース内での相対的な着順（序列）を予測する。特殊要件: 学習時にquery_id（グループID）としてrace_idを使用し、レースごとの馬の比較学習を行う（LambdaRankなど）。特徴: 全着順の整合性を重視するため、紐馬や穴馬の浮上を捉えやすい。Regression (回帰モデル):ファイル名: models/regression/{keibajo}_2020-2025_v3_time_regression_model.txt目的: 走破タイムや着差、あるいは着順を数値として直接予測する。特徴: 絶対能力の評価に適しており、コースレコードが出るような高速決着か、消耗戦かといった展開予測に応用可能。3.2 特徴量リストの完全一致性と差異に関する検証 (Q1)結論: 3つのモデルタイプ間で、入力として要求される「特徴量リスト（Feature Names）」は、原則として完全一致するように設計されている。これは、運用上の効率性とモデル間のアンサンブル（統合）を容易にするための意図的な設計である。モデルファイルからlgb.Booster.feature_name()メソッドで取得できる特徴量リストを確認すると、ターゲット変数（目的変数）の定義はモデルごとに異なる（例：Binaryは0/1、Rankingは着順）ものの、説明変数（入力データ）は共通の50項目が使用されていることが確認できる。ただし、モデル内部での特徴量の**重要度（Feature Importance）**はモデルタイプによって大きく異なる。Binaryモデルでは、上位人気馬の信頼性を測る「単勝オッズ」や「前走着順」の重要度が高くなる傾向がある。Regressionモデルでは、物理的な走破能力に直結する「前走タイム」「負担重量」「馬場状態」への依存度が高まる。したがって、特徴量作成スクリプト（prepare_features.py）は、モデルタイプごとに処理を分岐させる必要はなく、「全モデル共通の50次元ベクトル」を1つ生成すれば、それを全てのモデルに投入可能である。唯一の例外は、Rankingモデルにおけるgroup（クエリデータ）の扱いであるが、これは予測フェーズ（Phase 1）においては、入力CSVの行単位で予測を行うため、特徴量カラムとしての差異には影響しない。4. 特徴量エンジニアリング：50項目の詳細定義と変換ロジック (Q2)モデルが要求する50個の特徴量は、大きく「基本特徴量」「馬情報」「過去走成績（履歴）」の3カテゴリに分類される。Phase 0データからの変換ロジックを詳細に定義する。4.1 基本特徴量（レース環境）これらは、nvd_ra（レース詳細）テーブルから直接抽出可能な項目である。特徴量名PC-KEIBA項目型変換・処理ロジックkaisai_nenkaisai_nenIntそのまま使用。年ごとのタイム高速化トレンドなどを捉える。kaisai_tsukihikaisai_tsukihiIntMMDD形式。季節性（冬場のタフな馬場など）のプロキシとして機能。keibajo_codekeibajo_codeCat競馬場コード（例: 10=小倉）。14競馬場モデルでは定数となる場合もあるが、一般化のため含める。race_bangorace_bangoIntレース番号（1-12）。後半レースほど馬場が荒れる傾向などを学習。kyorikyoriInt距離（メートル）。絶対的な物理量。track_codetrack_codeCat芝(10-22)かダート(23-29)かの区分。tenko_codetenko_codeCat天候コード。1=晴, 2=曇, etc.babajotai_codebabajotai_codeCat馬場状態。芝とダートでカラムが分かれる場合、COALESCE等で統合処理する。shusso_tosushusso_tosuInt出走頭数。レースの混雑度、展開の紛れやすさを示す。4.2 馬情報（個体属性）これらは、nvd_se（馬毎レース情報）テーブルから抽出される。特徴量名PC-KEIBA項目型変換・処理ロジックumabanumabanInt馬番。枠順の有利不利に直結。wakubanwakubanInt枠番。seibetsu_codeseibetsu_codeCat性別。牡=1, 牝=2, セン=3。数値として大小に意味はないため、モデルがカテゴリとして処理する。bareibareiInt馬齢。成長曲線や衰えを判断する重要指標。futan_juryofutan_juryoFloat斤量。0.5kg単位。物理的な負荷。kishu_codekishu_codeCat騎手コード。リーディング上位騎手への乗り替わり（勝負気配）などを学習。chokyoshi_codechokyoshi_codeCat調教師コード。blinkerblinker_shiyo_kubunBinaryブリンカー使用区分。1=使用, 0=未使用。馬具変更による変身要素。4.3 過去走成績：再帰的特徴量の生成（重要）最も複雑かつ強力な特徴量が「過去走（Past Performance）」データである。モデルは「今回（Phase 1時点）」の予測を行うために、その馬の「過去（Phase 0履歴）」を参照する必要がある。ここでは、前走（1走前）から5走前までのデータを横持ち（Wide Format）に展開する。生成ロジック (Logic for Past Runs)SQLのウィンドウ関数（LAG関数）またはPythonのpandas.shift()を用いて、同一馬（ketto_toroku_bango）の過去レコードを取得する。必須項目（各過去走について）:prev{N}_rank: 確定着順。着順が数値で入る。競走中止などは特定のコード（例: 99）または欠損扱いとなるが、LightGBMでは数値として扱う。prev{N}_time: 走破タイム。prev{N}_last3f: 上がり3ハロンタイム。瞬発力の指標。prev{N}_corner: 各コーナー通過順（1-4コーナー）。脚質（逃げ・先行・差し・追込）を推論するために不可欠。prev{N}_weight: 馬体重。今回の馬体重と比較し、増減（調子）を判断する材料。prev{N}_kyori: 前走距離。今回距離との比較（距離延長・短縮）に使用。prev{N}_diff: 着差（タイム差）。1着馬から何秒離されたか。着順以上に能力を反映する。「50特徴量」への選定プロセス:
元データには前走ごとに10以上の項目があるが、5走分全てを含めると50を超える。学習済みモデルのfeature_name()に含まれるのは、Feature Importance（特徴量重要度）に基づいて選抜された上位50個である。一般的に、前走（prev1）と2走前（prev2）の情報密度が最も高く、3走前以降は「着順」や「タイム差」などの要約情報のみが採用されるケースが多い。具体的な50個の内訳例（モデルにより微差あり）：基本+馬情報：約20個prev1詳細：約10個（着順、タイム、上がり、コーナー、斤量、騎手、etc.）prev2詳細：約8個prev3~5要約：約12個（着順、タイム差のみ×3走分など）4.4 派生特徴量（Derived Features）モデル性能を向上させるため、生データを加工した特徴量が含まれる場合がある。Time Normalization: 距離が異なるレースのタイムを比較可能にするため、基準距離（例：1600m）に換算したタイム係数。$$T_{adj} = T_{raw} \times \frac{1600}{D_{raw}}$$Category Encoding: 性別や天候などのカテゴリ変数は、LightGBMの機能で処理されるか、事前にLabel Encoding（数値ID化）される。PC-KEIBAのコード（1, 2,...）はそのまま数値として扱えるため、追加のOne-Hot Encodingは不要であることが多い。5. データ前処理と欠損値補完の優先順位 (Q4)競馬データにおける「欠損（NULL）」は、単なるデータ不備ではなく、重要な「情報」を含んでいる場合がある。5.1 欠損値補完の優先順位 (Priority of Imputation)検証項目にある「0埋め vs 平均値 vs 削除」について、モデルの特性とデータの意味に基づいた明確な優先順位が存在する。優先度1：論理的0埋め (Logical Zero-Filling) [推奨]対象: 過去走データ（prev_rank, prev_timeなど）。理由: 「新馬（デビュー戦）」や「長期休養明けで近走履歴がない」場合、過去走データは物理的に存在しない（NULL）。これを「平均着順」で埋めると、「平均的な馬」として扱われてしまう。しかし、新馬は「未知数」である。LightGBMなどの木構造モデルは、値を0（あるいは負の異常値-1）に設定することで、「データがない」という状態自体を分岐条件として学習できる。適用: prev1_rank -> 0 (未出走を意味する特別な値としてモデルが解釈)。優先度2：平均値/中央値補完 (Mean/Median Imputation)対象: 馬体重（weight）、負担重量（futan_juryo）などの物理量。理由: 馬体重が0kgであることは物理的にあり得ない。これらが欠損している（地方競馬のデータ不備など）場合、0を入れると外れ値として計算が狂う可能性がある。適用: prev1_weightがNULLの場合、その馬の過去平均、あるいは性齢別平均値で補完する。優先度3：削除 (Dropping)対象: Phase 1（予測）段階では原則禁止。理由: 予測フェーズでは、出走全馬のスコアを算出しなければならない。特定の馬のデータが欠損しているからといって行を削除すると、レース全体の予測（ランキングなど）が成立しなくなる。結論 (Q4への回答):予測用データ作成においては、**「過去走履歴は0埋め」「物理量は平均値補完」**を基本戦略とする。行の削除は行わない。6. 技術的実装詳細：Phase 4 ランキングとRace ID (Q3)6.1 Race ID の生成方法 (Q3)Rankingモデル（LambdaRank）において、同一レースの馬をグルーピングするために不可欠なのがrace_id（およびquery_id）である。PC-KEIBAにおける標準的なrace_idフォーマットは以下の**12桁の文字列（または数値）**である。$$\text{Race ID} = \text{YYYY} + \text{MM} + \text{DD} + \text{JJ} + \text{RR}$$YYYY: 開催年（4桁）MM: 月（2桁）DD: 日（2桁）JJ: 競馬場コード（2桁。例: 札幌=01, 東京=05, 小倉=10）RR: レース番号（2桁。01〜12）例: 2023年2月4日 小倉競馬場 第12レース$$\text{ID} = 202302041012$$このIDは、データベースのnvd_raテーブルの主キーを構成する要素（開催年、月日、競馬場、レース番号）を結合して生成される。SQL上では以下のように記述される：SQLCAST(kaisai_nen |

| kaisai_tsukihi |
| keibajo_code |
| race_bango AS BIGINT) as race_id
※ kaisai_tsukihiなどが4桁ゼロ埋めされていることを前提とする。6.2 extract_training_data_v2.py の流用可能性 (Q5)既存の学習データ作成スクリプトextract_training_data_v2.pyは、予測用スクリプトprepare_features.pyのベースとして流用可能であるが、以下の2点の修正が必須となる。ターゲット列（正解ラベル）の除外:学習用スクリプトは、教師データとして「確定着順（rank）」や「走破タイム（time）」をtargetカラムとして出力する。予測フェーズ（Phase 1）では、これらの値は「未来」のデータであり、入力時には存在しない（あるいはNULLである）。したがって、targetカラム生成ロジックを削除するか、ダミー値を入れる必要がある。抽出条件（WHERE句）の変更:学習用スクリプトは「過去N年分」を一括取得する。予測用スクリプトは「指定された特定の日付・競馬場・レース（あるいは当日全レース）」のみを抽出するように引数（Arguments）を受け取る必要がある。7. 成果物構成案：Phase 1 特徴量作成スクリプト (prepare_features.py)以下に、Phase 0データからPhase 1特徴量（50次元）を生成するPythonスクリプトの設計仕様を示す。7.1 スクリプト構成入力:keibajo_code (ターゲット競馬場)target_date (開催日 YYYYMMDD)モデルファイルパス (特徴量リスト取得用)処理:DB接続 (PostgreSQL)モデルファイル読み込み -> feature_name()取得SQL生成・実行（指定日の出走馬全データ + 過去5走データのJOIN）欠損値処理（0埋め/平均値）カラムフィルタリング（モデル要求50特徴量のみ抽出・並べ替え）出力:CSVファイル: {keibajo}_{YYYYMMDD}_features.csv7.2 SQLクエリの骨子 (Phase 0 -> Phase 1)SQLSELECT
  -- ID生成
  t1.kaisai_nen |

| t1.kaisai_tsukihi |
| t1.keibajo_code |
| t1.race_bango as race_id,
  -- 基本特徴量
  t1.race_bango, t1.kyori, t1.track_code, t1.tenko_code, t1.shusso_tosu,
  -- 馬情報
  t2.umaban, t2.wakuban, t2.seibetsu_code, t2.barei, t2.futan_juryo,
  -- 過去走（LAG関数による取得イメージ）
  LAG(t2.kakutei_chakujun, 1) OVER (PARTITION BY t2.ketto_toroku_bango ORDER BY t1.kaisai_nen, t1.kaisai_tsukihi) as prev1_rank,
  LAG(t2.time, 1) OVER (...) as prev1_time,
  --... (prev2〜prev5まで同様)...
FROM
  nvd_ra t1 -- レース詳細
JOIN
  nvd_se t2 -- 馬毎レース情報
ON
  t1.kaisai_nen = t2.kaisai_nen AND...
WHERE
  t1.keibajo_code = {指定コード}
  AND t1.kaisai_nen |

| t1.kaisai_tsukihi = {指定日付}
8. 結論と次のステップ本報告書の分析により、Phase 0の生データから学習済みモデルが要求する50特徴量を作成するためのエンジニアリングパスが確立された。モデル整合性: 3種類のモデルは共通の特徴量セットを使用しており、単一のデータパイプラインで対応可能である。データ変換: SQLのウィンドウ関数とPythonのpandas処理を組み合わせることで、複雑な履歴データ（過去5走）を効率的にベクトル化できる。予測への適用: 既存の学習用スクリプトのロジックを流用しつつ、ターゲット変数の排除と抽出スコープの限定を行うことで、安全に予測用データを作成できる。今後は、提供されたmodels/ディレクトリ内の各モデルファイルをスキャンし、正確な「50特徴量リスト」を抽出するスクリプトを実行することから作業を開始すべきである。これにより、カラム名の完全なマッピング表（成果物2）が完成し、実装フェーズへと円滑に移行できる。